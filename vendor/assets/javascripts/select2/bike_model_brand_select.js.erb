(function(){

    var ModelNestedBrandSelectBuilder = function(conf){	

        var configs = sel2mix.parsed_conf(conf)		
	configs.api_url = conf.api_url

	var msg =  sel2mix.obj_merge(
	    [I18n.translate('sel2ui.messages')]
	)

	sel2mix.asClearable.call(this, configs.selector)

	/*
	  Tagging mode for bike model nested brands.
	  
	  Tagging implies that the select element is used 
	  for brand_model_lookup_create.
	  
	  This is where the model is found from a lookup, or a
	  new model is added (as selected option) if the 
	  correct model is not found.
	  
	  It may also be necessary to add a new brand when
	  adding a new model.
	*/
	var ui_container = new sel2mix.BikeBMContainer()
	var container_selector = ui_container.selector()
	var inner_container_selector = ui_container.inner_selector

	var enable_map = {
	    lookup:{lookup:true,create:false},
	    create:{lookup:false,create:true}
	}

	var enable_sel_elements = function(enable, group){
	    var inner_container = 
		jQuery(inner_container_selector(group))
	    var command = (enable) ? 'enable' : 'disable'

	    inner_container.children('input').each(function(){
		jQuery(this).select2(command)
		if(! enable ){
		    sel2mix.clear_selection(this)
		}
	    })

            // coerce the radio to match enabled status
	    var radio = jQuery(container_selector+" input[value="+group+"]:radio")
	    radio.attr('checked', enable)
	}
	var toggle_elements = function(e){
	    var element = jQuery(e.target)
	    var optn = element.attr('value')
	    var checked = !!element.attr('checked')
	    
	    enable_sel_elements(enable_map[optn]['lookup'] && checked, 'lookup')
	    enable_sel_elements(enable_map[optn]['create'] && checked, 'create')
	}

	// Accessor method that indicates what input
	// is active when in tagging mode
	var active_input_group = function(){
	    if(configs.tagging){
		jQuery(container_selector+" [type=radio]input").each(function(){
		    if(btn.attr('checked')){
			return btn.attr('value')
		    }
		})
		    }
	    return null;
	}

	var trigger_tagging_action = function(e){
	    if(e.val != sel2mix.TAGGING_ID()){
		return
	    }
	    
	    // Get the brand for the given trigger
	    // Need to do this before clearing the select
	    var data = jQuery(configs.selector).select2('data')
	    var b_id = data.brand_id

	    // force a toggle of the interface
	    enable_sel_elements(false, 'lookup')
	    enable_sel_elements(true, 'create')

	    // select the brand
	    var inner_container = 
		jQuery(inner_container_selector('create'))
	    var brand_sel_class =
		inner_container_selector('create')+
		" <%="*.#{Select2BikeBinder::Builder::BrandSelect.selector_class}"%>"
	    jQuery(brand_sel_class).
		select2('data', {id:b_id,text:data.brand})
	    
	    // open the model select
	    var model_sel_class = 
		inner_container_selector('create')+
		" <%="*.#{Select2BikeBinder::Builder::ModelSelect.selector_class}"%>"
	    jQuery(model_sel_class).select2('open')
	}


	var tagging_link = function(brand_node){
	    return {brand:brand_node.text,
		    brand_id:brand_node.brand_id,
		    id:sel2mix.TAGGING_ID(),
		    is_tag:true,
		    text:"Enter a new "+brand_node.text+" model."}
	}


	// parse the results into the format expected by Select2.
	var query_parser = function(data, page) {

	    var arr = data.results || []
	    for(var i=0; i<arr.length; i++){
		if(arr[i].direct){
		    arr[i].children.unshift(tagging_link(arr[i]))
		}
	    }

	    data.results = arr;
	    return data;
	}

	this.build = function(){
	    var params = {
	    	placeholder: "Search for a bike brand or model",
		minimumInputLength: 2,
		allowClear:true,
		ajax: {
		    url: configs.api_url,
		    dataType: 'json',
		    quietMillis: sel2mix.q_delay,
		    data: function (term, page) {
			return {
			    q: term, // search term
			};
		    },
		    results: query_parser
		},
		formatResult: function(item){
		    if(item.is_tag){
			return "<em style='text-decoration: underline;'>"+item.text+'...</i>'
		    }else{
			return item.text
		    }
		}, 
		formatSelection: function(item){
		    return '<strong>'+item.brand+',</strong> ' + item.text
		},
		dropdownCssClass: "bigdrop" // apply css that makes the dropdown taller
	    } // params ={...}

	    jQuery(configs.selector).select2(params);    
	    
	    if(configs.tagging){
		// Put model nested brands into tagging mode
		// Attach Enable/Disable events
		jQuery(container_selector+" [type=radio]input").each(function(){
		    var btn = jQuery(this)
		    btn.on('change', toggle_elements)
		})
	        jQuery(configs.selector).on("change", trigger_tagging_action)
	    }

	    

	} // this.build = function


    } //  var ModelNestedBrandSelectBuilder

    var BrandSelectBuilder = function(conf){	
	var configs = sel2mix.parsed_conf(conf)		
	configs.api_url = conf.api_url

	var msg =  sel2mix.obj_merge(
	    [I18n.translate('sel2ui.messages')]
	)


	// When the brand changes, the selection
	// for model is no longer valid, so it
	// needs to be cleared. 
	// And for convenience, the selection
	// should be openend unless the brand is cleared
	var trigger_model_update = function(e){
	    if(!configs.tagging){
		return
	    }

	    var ui_container = new sel2mix.BikeBMContainer()
	    var model_sel_class =
		ui_container.inner_selector('create')+
		" <%="*.#{Select2BikeBinder::Builder::ModelSelect.selector_class}"%>"
	    var model_sel = jQuery(model_sel_class)

	    var brand_sel_class = ui_container.inner_selector('create')+
		" <%="*.#{Select2BikeBinder::Builder::BrandSelect.selector_class}"%>"
	    var brand_sel = jQuery(brand_sel_class)

	    if(model_sel){
		sel2mix.clear_selection(model_sel)
		
		if(e.val)
		    model_sel.select2('open')	    
	    }
	}

	var query_parse = (configs.tagging) ? 
	    sel2mix.tagFlatResults :
	    function(data, page){return data}

	this.build = function(){
	    var params = {
	    	placeholder: "Search for a bike brand",
		minimumInputLength: 2,
		allowClear: true,
		ajax: {
		    url: configs.api_url,
		    dataType: 'json',
		    quietMillis: sel2mix.q_delay,
		    data: function (term, page) {
			return {
			    q: term, // search term
			};
		    },
		    results: query_parse
		},
		formatResult: function(item){
		    return item.text;
		}, 
		formatSelection: function(item){
		    return item.text
		},
		dropdownCssClass: "bigdrop" // apply css that makes the dropdown taller
	    }

	    $(configs.selector).select2(params);    

	    $(configs.selector).on('change', trigger_model_update);    

	} // this.build = function

    } // var BrandSelectBuilder


    var ModelSelectBuilder = function(conf){	
	var configs = sel2mix.parsed_conf(conf)		
	configs.api_url = conf.api_url

	var msg =  sel2mix.obj_merge(
	    [I18n.translate('sel2ui.messages')]
	)

	var ui_container = new sel2mix.BikeBMContainer()

	var constraints = function(){
	    var brand_sel_class = 
		ui_container.inner_selector('create')+
		" <%="*.#{Select2BikeBinder::Builder::BrandSelect.selector_class}"%>"
	    data = jQuery(brand_sel_class).select2('data') || {id:''}
	    
	    return (data.is_tag ) ? {id:''} : {brand:data.id}
	}
	
	var query_data = function(term, page){
	    var brand_sel_class = 
		ui_container.inner_selector('create')+
		" <%="*.#{Select2BikeBinder::Builder::BrandSelect.selector_class}"%>"
	    data = jQuery(brand_sel_class).select2('data') || {id:''}

	    // create the request parameters
	    return sel2mix.obj_merge(
		[{q: term}, constraints()])
	}

	// Synchronize the model_id select when in tagging mode
	var trigger_model_id_update = function(e){
	    if(!configs.tagging){
		return
	    }
	    sel = jQuery(configs.selector)
	    data = sel.select2('data')

	    var model_id_sel_class = 
		ui_container.inner_selector('lookup')+
		" <%="*.#{Select2BikeBinder::Builder::ModelNestedBrandSelect.selector_class}"%>"
	    model_id_sel = jQuery(model_id_sel_class)
	    model_id_data = model_id_sel.select2('data')

	    // check if the model_id has data
	    if(!model_id_data){
		// missing model_id implies that data is a tag
		data = null
	    }
	    if(data && data.is_tag){ data=null}
	    
	    if(data){
		// brand and model info is all in data
		// update the model_id selection with brand and model information
		model_id_sel.select2('data', data)
	    }else{
		// clear the model_id selection
		sel2mix.clear_selection(model_id_sel)
		return
	    }
	}

	// parse the results into the format expected by Select2.
	var query_parse = 
	    function(data, page){
		if (configs.tagging) {
		    return sel2mix.tagFlatResults(data, page)
		}else{
		    return data
		}
	    }

	this.build = function(){
	    var params = {
	    	placeholder: "Search for a bike model",
		minimumInputLength: 2,
		allowClear: true,
		ajax: {
		    url: configs.api_url,
		    dataType: 'json',
		    quietMillis: sel2mix.q_delay,
		    data: query_data,
		    results: query_parse
		},
		formatResult: function(item){
		    return item.text;
		}, 
		formatSelection: function(item){
		    return item.text
		},
		dropdownCssClass: "bigdrop" // apply css that makes the dropdown taller
	    }

	    $(configs.selector).select2(params);    


	    jQuery(configs.selector).on("change", trigger_model_id_update)

	} // this.build = function

    } // var BikeModelSelectBuilder


    
    // Public access to the buildier
    this.ModelNestedBrandSelectBuilder = {
	selector:"<%="*.#{Select2BikeBinder::Builder::ModelNestedBrandSelect.selector_class}"%>",
	build:function(args){
	    return (new ModelNestedBrandSelectBuilder(args)).build()
	}
    }

    this.BrandSelectBuilder = {
	selector:"<%="*.#{Select2BikeBinder::Builder::BrandSelect.selector_class}"%>",
	build:function(args){
	    return (new BrandSelectBuilder(args)).build()
	}
    }

    this.ModelSelectBuilder = {
	selector:"<%="*.#{Select2BikeBinder::Builder::ModelSelect.selector_class}"%>",
	build:function(args){
	    return (new ModelSelectBuilder(args)).build()
	}
    }

}).apply(sel2); // apply to the sel2 namespace